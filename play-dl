#!/usr/bin/env bash

 #####  #    # #    #  ####  License: GNU GPLv3
 #    # ##   # #    # #      Year: 2021
 #      # #  # #    #  ####
 #  ### #  # # #    #      # https://github.com/gnusd
 #    # #   ## #    # #    # http://gnusd.xyz
 #####  #    #  ####   ####

# FILENAME: play-dl

# check which flags are passed
FLAG_1="$(echo "$1" | grep  '-')"
FLAG_2="$(echo "$2" | grep  '-')"
URL_1="$(echo "$1" | grep -E '^(http|https)://')"
URL_2="$(echo "$2" | grep -E '^(http|https)://')"

# Development paths
# DIR_PATH="$HOME/tmp/play-dl"
# DL_FROM_FILE_DIR="$HOME/tmp/play-dl/files"

# paths to different download related stuff
DIR_PATH="$HOME/mnt/downloads/play-dl"
DL_FROM_FILE_DIR="$HOME/mnt/downloads/play-dl/files"
DL_FILE="urls"
LOG_FILE="logs-dl"

# date for log, I like varibles
DATE="$(date '+%Y-%m-%d')"

#development paths
# VIDEO_PATH="$HOME/tmp/video"
# DOC_PATH="$HOME/tmp/documentaries"
# TV_SERIES_PATH="$HOME/tmp/tv-shows"

# destination paths for video and dockumentaries
VIDEO_PATH="$HOME/mnt/video/filmer"
DOC_PATH="$HOME/mnt/video/dokumentÃ¤rer/filmer"
TV_SERIES_PATH="$HOME/mnt/video/tv-serier"

# username and password for viafree
[ -f "$HOME/bin/SECRETS" ] && source "$HOME/bin/SECRETS"
# username and password for viafree in dev enviroment
[ -f "$HOME/.local/git/local/code/development/SECRETS" ] && source "$HOME/.local/git/local/code/development/SECRETS"

# download methods
METHOD_SVTPLAY="svtplay-dl --merge-subtitle"
METHOD_TV4="svtplay-dl --merge-subtitle"
METHOD_YT="youtube-dl --all-subs"
#check for where the URL are
sort_urls () {
		if [ -n "$URL_1" ]
		then
				URL="$URL_1"
		elif [ -n "$URL_2" ]
		then
				URL="$URL_2"
		elif [ -n "$1" ]
		then
				URL="$1"
		fi
		export URL

		# checking what site to download from
		case "$URL" in
				*svt*)
						DL="$METHOD_SVTPLAY"
						echo "$DL"	
						;;
				*tv4*)
						DL="$METHOD_TV4"
						echo "$DL"
						;;
				*pluto*)
						DL="$METHOD_SVTPLAY"
						echo "$DL"
						;;
		esac

}

# checking which flag if any is passed
sort_flags () {
		if [ -n "$FLAG_1" ]
		then
				FLAG="$FLAG_1"

		elif [ -n "$FLAG_2" ]
		then
				FLAG="$FLAG_2"

		fi
		export FLAG
}

#removing line from urls file after download is done
delete_line () {
		sed -i '1d' "$DL_FROM_FILE_DIR/$DL_FILE"
}

# write to log file
write_log () {
		printf "%s \t %s \t [%s]\n"   "$DATE" "$1" "$FLAG" >> "$DL_FROM_FILE_DIR/$LOG_FILE"
}

# download tv-shows to a tmp directory
dl_tv_shows () {
	DL="$(sort_urls "$1")"
	URL="$1"
	[ -f  "$DL_FROM_FILE_DIR/$LOG_FILE" ] && last_dl_date="$(sort < "$DL_FROM_FILE_DIR/$LOG_FILE" | grep "$URL" | tail -1 | sed 's/\(.*\)\s.*/\1/')"
	tmpdir="$RANDOM""$RANDOM"
	mkdir -p "$DIR_PATH/$tmpdir"
	cd "$DIR_PATH/$tmpdir" || exit

	# check if link points to viafree
	check_url="$(echo "$DL" | grep 'u')"

	# TODO: make the if statement easier
	if [ -n "$last_dl_date" ]
	then
		if [ -n "$check_url" ]
		then
			svtplay-dl -A --after-date "$last_dl_date" "$URL"
		fi
	else
		if [ -n "$check_url" ]
		then
			svtplay-dl -A "$URL"
		fi
	fi

	echo "$tmpdir"
}

# rename and move files to tv-show directory
move_tv_shows () {

	tmpdir="$1"
	cd "$DIR_PATH/$tmpdir" || exit
	for ep in *
	do
		if [ -f "$ep" ]
		then
			# getting season and episod number
			season="$(echo "$ep" | sed 's/^.*\.s\([0-9]*\).*/\1/')"
			episod="$(echo "$ep" | sed 's/^.*s[0-9]*e\([0-9]*\).*/\1/')"

			# creating season directory
			season_dir="season_$season"
			dir_name="$(echo "$ep" | sed s'/^\(.*\)\.s[0-9].*/\1/' | sed s'/\./_/g')"

			# creating file name
			ep_name="$dir_name""_s""$season""e""$episod"".mp4"

			# checking to see if directory for the tv-show and season is created
			[ ! -d "$DIR_PATH/$tmpdir/$dir_name" ] && mkdir -p "$DIR_PATH/$tmpdir/$dir_name"
			[ ! -d "$DIR_PATH/$tmpdir/$dir_name/$season_dir" ] && mkdir -p "$DIR_PATH/$tmpdir/$dir_name/$season_dir"

			# move file into directory
			mv "$DIR_PATH/$tmpdir/$ep" "$DIR_PATH/$tmpdir/$dir_name/$season_dir/$ep_name"
		fi
	done
	mv "$DIR_PATH/$tmpdir/$dir_name"  "$TV_SERIES_PATH"
}

# renaming and moving to the correct directory
rename_move () {
		# get file identifyer
		file_id="$(echo "$1" | sed 's#.*/##' | sed 's#.*\.##;s#.*-##')"

		# get mp4 filesname
		lmf="$(/usr/bin/find . -maxdepth 1 -type f -name "*.mp4" | grep "$file_id" | sed s'/^\.\/\(.*\)/\1/')"
		[ -z "$lmf" ] && lmf="$(/usr/bin/find . -maxdepth 1 -type f -name "*.mp4" | sort | tail -1 | sed s'/^\.\/\(.*\)/\1/')"

		if [ -n "$lmf" ]
		then
			pluto="$(echo "$lmf" | grep "pluto.tv")"
			if [ -z "$pluto"]
			then
				# create a new name for the file
				dir_name="$(echo "$lmf" | sed s'/^\(.*\)-.*-.*play.*/\1/g' | sed 's/\./_/g')" 
			else
				dir_name="$(echo "$lmf" | sed s'/^pluto.tv-\(.*\)-*plutotv.*/\1/g' | sed 's/\./_/g')" 
			fi
				comp_1="$(echo "${dir_name#*_}" | sed 's/_//g')"
				comp_2="$(echo "${dir_name%%_*}" | sed 's/-//g')"

				# check to see if name dir_name contains the name twice
				if [ "$comp_1" == "$comp_2" ]
				then
						dir_name="$(echo "${dir_name#*_}")"
				fi

				nfn="$dir_name".mp4

				# checking if the destination is video or documentary
				if [ "$FLAG" == "-f" ]
				then
						[ ! -d "$VIDEO_PATH/$dir_name" ] && mkdir "$VIDEO_PATH/$dir_name"
						[ ! -f "$VIDEO_PATH/$dir_name/$nfn" ] && mv "$DIR_PATH/$lmf" "$VIDEO_PATH/$dir_name/$nfn"

				elif [ "$FLAG" == "-d" ]
				then
						[ ! -d "$DOC_PATH/$dir_name" ] && mkdir "$DOC_PATH/$dir_name"
						[ ! -f "$DOC_PATH/$dir_name/$nfn" ] && mv "$DIR_PATH/$lmf" "$DOC_PATH/$dir_name/$nfn"

				elif [ -z "$FLAG" ] && [ -n "$URL" ]
				then
						[ ! -d "$VIDEO_PATH/$dir_name" ] && mkdir "$VIDEO_PATH/$dir_name"
						[ ! -f "$VIDEO_PATH/$dir_name/$nfn" ] && mv "$DIR_PATH/$lmf" "$VIDEO_PATH/$dir_name/$nfn"
				fi
		else
				write_log "Could not find the file, lmf = $lmf" "$1"
		fi
}

# read the urls file
read_download () {
		while read -r line
		do
				DL="$(sort_urls "$line")"
				eval "$DL" "$line"
				rename_move "$line"
				delete_line
				write_log "$line"
		done < "$DL_FROM_FILE_DIR/$DL_FILE"

}

# read the urls file
read_dl_file_tv_shows () {
		while read -r line
		do
				tmpdir="$(dl_tv_shows "$line")"
				move_tv_shows "$tmpdir"
				delete_line
				write_log "$line"
		done < "$DL_FROM_FILE_DIR/$DL_FILE"

}

backup_url_file () {
	cp "$DL_FROM_FILE_DIR/$DL_FILE" "$DL_FROM_FILE_DIR/$DL_FILE".bak
}

cd "$DIR_PATH" || exit

sort_flags

# if there is no flag passed check if there is a url
if [ -z "$FLAG" ]
then
		sort_urls
		eval "$DL" "$URL"
		rename_move
		write_log

# if there is a flag
elif [[ "$FLAG" == "-f" ]] || [[ "$FLAG" == "-d" ]]
then
		if [ -s "$DL_FROM_FILE_DIR/$DL_FILE" ]
		then
        		backup_url_file
				export FLAG
				read_download
		else
				echo "URLS file is empthy"
		fi
elif [[ "$FLAG" == "-s" ]]
then
        backup_url_file
        export FLAG
		read_dl_file_tv_shows

# if there is no flag and no url
else
		echo "No flags and no url, nothing to do."
fi

unset VIA_USER
unset VIA_PASS
unset FLAG
